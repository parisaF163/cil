/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 7 "list.c"
struct state_t {
   int list[5] ;
   int end ;
};
#line 5
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 8 "list.c"
struct state_t *st  ;
#line 9 "list.c"
void o_new(void) 
{ 
  void *tmp ;

  {
#line 10
  tmp = malloc(sizeof(struct state_t ));
#line 10
  st = (struct state_t *)tmp;
#line 11
  st->end = -1;
#line 12
  return;
}
}
#line 13 "list.c"
int o_add(int v ) 
{ 
  int rv ;
  int i ;

  {
#line 14
  rv = 1;
#line 15
  i = 0;
#line 15
  while (i <= st->end) {
#line 16
    if (st->list[i] == v) {
#line 16
      rv = 0;
#line 16
      break;
    }
#line 15
    i ++;
  }
#line 18
  if (rv == 1) {
#line 18
    if (st->end == 5) {
#line 18
      rv = 0;
    } else {
#line 19
      st->list[st->end + 1] = v;
#line 19
      (st->end) ++;
    }
  } else {
#line 19
    st->list[st->end + 1] = v;
#line 19
    (st->end) ++;
  }
#line 20
  return (rv);
}
}
#line 22 "list.c"
int o_rm(int v ) 
{ 
  int rv ;
  int i ;

  {
#line 23
  rv = 0;
#line 24
  i = 0;
#line 24
  while (i <= st->end) {
#line 25
    if (st->list[i] == v) {
#line 26
      st->list[i] = st->list[st->end];
#line 26
      (st->end) --;
#line 26
      rv = 1;
#line 26
      break;
    }
#line 24
    i ++;
  }
#line 28
  return (rv);
}
}
#line 30 "list.c"
int o_contains(int v ) 
{ 
  int rv ;
  int i ;

  {
#line 31
  rv = 0;
#line 32
  i = 0;
#line 32
  while (i <= st->end) {
#line 33
    if (st->list[i] == v) {
#line 33
      rv = 1;
#line 33
      break;
    }
#line 32
    i ++;
  }
#line 35
  return (rv);
}
}
#line 37 "list.c"
int o_isempty(void) 
{ 


  {
#line 38
  return (st->end > -1);
}
}
#line 40 "list.c"
int o_add4(int *t ) 
{ 


  {
#line 41
  *t = 42;
#line 42
  return (0);
}
}
#line 44 "list.c"
int main(void) 
{ 
  int *t ;

  {
#line 45
  t = & st->end;
#line 46
  o_add4(t);
#line 47
  return (0);
}
}
